import axios from 'axios';
import logger from '../utils/Logger.js';
import fs from 'fs';
import path from 'path';

/**
 * æ•°æ®æºç®¡ç†å™¨ - åŠ¨æ€ç®¡ç†å¤šä¸ªAPIæ•°æ®æº
 */
class DataSourceManager {
  constructor() {
    this.sources = [];
    this.configFile = path.join(process.cwd(), 'data', 'api-sources.json');
    this.healthCheckInterval = 60000; // 1åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
    this.healthCheckTimer = null;
    this.loadSources();
  }

  /**
   * åŠ è½½æ•°æ®æºé…ç½®
   */
  loadSources() {
    try {
      // ç¡®ä¿dataç›®å½•å­˜åœ¨
      const dataDir = path.dirname(this.configFile);
      if (!fs.existsSync(dataDir)) {
        fs.mkdirSync(dataDir, { recursive: true });
      }

      // å¦‚æžœé…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ›å»ºé»˜è®¤é…ç½®
      if (!fs.existsSync(this.configFile)) {
        const defaultSources = {
          sources: [
            {
              id: 'api_official',
              name: 'å®˜æ–¹API',
              baseUrl: 'https://api.apiose122.com',
              type: 'official',
              priority: 1,
              enabled: true,
              needsProxy: true,
              status: 'unknown',
              responseTime: 0,
              successRate: '0.00',
              lastCheck: null,
              errors: 0,
              totalRequests: 0,
              successRequests: 0,
              endpointHealth: {}
            },
            {
              id: 'api_3650062',
              name: '3650062å¤‡ç”¨',
              baseUrl: 'https://3650062.com/api',
              type: 'backup',
              priority: 2,
              enabled: true,
              needsProxy: false,
              status: 'unknown',
              responseTime: 0,
              successRate: '0.00',
              lastCheck: null,
              errors: 0,
              totalRequests: 0,
              successRequests: 0,
              endpointHealth: {}
            },
            {
              id: 'api_168official',
              name: '168å®˜æ–¹API',
              baseUrl: 'https://stg-168-api.api861.com',
              type: 'backup',
              priority: 3,
              enabled: false,
              needsProxy: false,
              status: 'unknown',
              responseTime: 0,
              successRate: '0.00',
              lastCheck: null,
              errors: 0,
              totalRequests: 0,
              successRequests: 0,
              endpointHealth: {}
            }
          ]
        };

        fs.writeFileSync(this.configFile, JSON.stringify(defaultSources, null, 2));
        this.sources = defaultSources.sources;
      } else {
        const data = JSON.parse(fs.readFileSync(this.configFile, 'utf8'));
        this.sources = data.sources || [];
      }

      logger.info(`âœ… åŠ è½½äº† ${this.sources.length} ä¸ªæ•°æ®æºé…ç½®`);
    } catch (error) {
      logger.error('åŠ è½½æ•°æ®æºé…ç½®å¤±è´¥:', error);
      this.sources = [];
    }
  }

  /**
   * ä¿å­˜æ•°æ®æºé…ç½®
   */
  saveSources() {
    try {
      fs.writeFileSync(this.configFile, JSON.stringify({ sources: this.sources }, null, 2));
      logger.info('âœ… æ•°æ®æºé…ç½®å·²ä¿å­˜');
      return true;
    } catch (error) {
      logger.error('ä¿å­˜æ•°æ®æºé…ç½®å¤±è´¥:', error);
      return false;
    }
  }

  /**
   * æ·»åŠ æ–°æ•°æ®æº
   */
  addSource(sourceConfig) {
    const newSource = {
      id: sourceConfig.id || `api_${Date.now()}`,
      name: sourceConfig.name,
      baseUrl: sourceConfig.baseUrl,
      type: sourceConfig.type || 'custom',
      priority: sourceConfig.priority || 99,
      enabled: sourceConfig.enabled !== false,
      needsProxy: sourceConfig.needsProxy || false,
      status: 'unknown',
      responseTime: 0,
      successRate: '0.00',
      lastCheck: null,
      errors: 0,
      totalRequests: 0,
      successRequests: 0,
      endpointHealth: {}
    };

    this.sources.push(newSource);
    this.saveSources();

    logger.info(`âœ… æ·»åŠ æ–°æ•°æ®æº: ${newSource.name}`);
    return newSource;
  }

  /**
   * åˆ é™¤æ•°æ®æº
   */
  removeSource(sourceId) {
    const index = this.sources.findIndex(s => s.id === sourceId);
    if (index !== -1) {
      const removed = this.sources.splice(index, 1)[0];
      this.saveSources();
      logger.info(`âœ… åˆ é™¤æ•°æ®æº: ${removed.name}`);
      return true;
    }
    return false;
  }

  /**
   * æ›´æ–°æ•°æ®æºé…ç½®
   */
  updateSource(sourceId, updates) {
    const source = this.sources.find(s => s.id === sourceId);
    if (source) {
      Object.assign(source, updates);
      this.saveSources();
      logger.info(`âœ… æ›´æ–°æ•°æ®æº: ${source.name}`);
      return source;
    }
    return null;
  }

  /**
   * å¯ç”¨/ç¦ç”¨æ•°æ®æº
   */
  toggleSource(sourceId, enabled) {
    const source = this.sources.find(s => s.id === sourceId);
    if (source) {
      source.enabled = enabled;
      this.saveSources();
      logger.info(`${enabled ? 'âœ… å¯ç”¨' : 'â¸ï¸ ç¦ç”¨'}æ•°æ®æº: ${source.name}`);
      return source;
    }
    return null;
  }

  /**
   * èŽ·å–æ‰€æœ‰æ•°æ®æº
   */
  getSources() {
    return this.sources;
  }

  /**
   * èŽ·å–å¯ç”¨çš„æ•°æ®æºï¼ˆæŒ‰ä¼˜å…ˆçº§æŽ’åºï¼‰
   */
  getAvailableSources() {
    return this.sources
      .filter(s => s.enabled && s.status !== 'error')
      .sort((a, b) => a.priority - b.priority);
  }

  /**
   * èŽ·å–æœ€ä½³æ•°æ®æº
   */
  getBestSource() {
    const available = this.getAvailableSources();

    // ä¼˜å…ˆé€‰æ‹©çŠ¶æ€ä¸ºhealthyçš„
    const healthy = available.find(s => s.status === 'healthy');
    if (healthy) return healthy;

    // å¦‚æžœæ²¡æœ‰healthyçš„ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨çš„
    return available[0] || null;
  }

  /**
   * å¥åº·æ£€æŸ¥ - å•ä¸ªæ•°æ®æº
   */
  async checkSourceHealth(source) {
    const startTime = Date.now();

    try {
      // æµ‹è¯•ä¸€ä¸ªç®€å•çš„ç«¯ç‚¹
      const testEndpoint = this.getTestEndpoint(source);
      const url = `${source.baseUrl}${testEndpoint}`;

      const response = await axios.get(url, {
        timeout: 10000,
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
          'Accept': 'application/json'
        }
      });

      const responseTime = Date.now() - startTime;

      // æ£€æŸ¥å“åº”
      if (response.status === 200) {
        // æ£€æŸ¥å“åº”æ•°æ®æ ¼å¼
        const isValidData = this.validateResponseData(response.data);

        if (isValidData) {
          // æ›´æ–°ç»Ÿè®¡
          source.totalRequests++;
          source.successRequests++;
          source.responseTime = responseTime;
          source.status = 'healthy';
          source.lastCheck = new Date().toISOString();
          source.successRate = ((source.successRequests / source.totalRequests) * 100).toFixed(2);

          logger.success(`âœ… [${source.name}] å¥åº·æ£€æŸ¥é€šè¿‡ - ${responseTime}ms`);
          return true;
        } else {
          // æ•°æ®æ ¼å¼é”™è¯¯
          source.totalRequests++;
          source.errors++;
          source.status = 'warning';
          source.lastCheck = new Date().toISOString();
          source.successRate = ((source.successRequests / source.totalRequests) * 100).toFixed(2);

          logger.warn(`âš ï¸ [${source.name}] æ•°æ®æ ¼å¼é”™è¯¯`);
          return false;
        }
      } else {
        // HTTPé”™è¯¯
        source.totalRequests++;
        source.errors++;
        source.status = 'error';
        source.lastCheck = new Date().toISOString();
        source.successRate = ((source.successRequests / source.totalRequests) * 100).toFixed(2);

        logger.error(`âŒ [${source.name}] HTTP ${response.status}`);
        return false;
      }
    } catch (error) {
      source.totalRequests++;
      source.errors++;
      source.status = 'error';
      source.lastCheck = new Date().toISOString();
      source.successRate = ((source.successRequests / source.totalRequests) * 100).toFixed(2);

      logger.error(`âŒ [${source.name}] å¥åº·æ£€æŸ¥å¤±è´¥:`, error.message);
      return false;
    }
  }

  /**
   * èŽ·å–æµ‹è¯•ç«¯ç‚¹
   */
  getTestEndpoint(source) {
    // æ ¹æ®baseUrlåˆ¤æ–­ä½¿ç”¨å“ªä¸ªæµ‹è¯•ç«¯ç‚¹
    if (source.baseUrl.includes('api.apiose122.com')) {
      return '/pks/getLotteryPksInfo.do?lotCode=10037';
    } else if (source.baseUrl.includes('3650062.com')) {
      return '/pks/getLotteryPksInfo.do?lotCode=10037';
    } else if (source.baseUrl.includes('stg-168-api')) {
      return '/pks/getLotteryInfo.do?lotCode=10037';
    } else {
      return '/pks/getLotteryPksInfo.do?lotCode=10037';
    }
  }

  /**
   * éªŒè¯å“åº”æ•°æ®
   */
  validateResponseData(data) {
    // æ£€æŸ¥åŸºæœ¬ç»“æž„
    if (!data) return false;

    // APIè¿”å›žerrorCode=0è¡¨ç¤ºæˆåŠŸ
    if (data.errorCode === 0 && data.result && data.result.data) {
      const resultData = data.result.data;

      // æ£€æŸ¥å¿…è¦å­—æ®µ
      if (resultData.serverTime && resultData.drawTime) {
        // æ£€æŸ¥æ•°æ®æ˜¯å¦è¿‡æœŸ
        const isExpired = this.checkDataExpired(resultData);
        return !isExpired;
      }
    }

    return false;
  }

  /**
   * æ£€æŸ¥æ•°æ®æ˜¯å¦è¿‡æœŸ
   */
  checkDataExpired(data) {
    try {
      if (!data.serverTime || !data.drawTime) {
        return true;
      }

      const serverTimestamp = new Date(data.serverTime).getTime();
      const drawTimestamp = new Date(data.drawTime).getTime();

      // å¦‚æžœæœåŠ¡å™¨æ—¶é—´è¶…è¿‡å¼€å¥–æ—¶é—´è¶…è¿‡10åˆ†é’Ÿï¼Œè®¤ä¸ºæ•°æ®è¿‡æœŸ
      const diffMinutes = (serverTimestamp - drawTimestamp) / 1000 / 60;

      return diffMinutes > 10;
    } catch (error) {
      return true;
    }
  }

  /**
   * å¥åº·æ£€æŸ¥ - æ‰€æœ‰æ•°æ®æº
   */
  async checkAllSourcesHealth() {
    logger.info('ðŸ¥ å¼€å§‹å¥åº·æ£€æŸ¥æ‰€æœ‰æ•°æ®æº...');

    const results = [];
    for (const source of this.sources) {
      if (source.enabled) {
        const result = await this.checkSourceHealth(source);
        results.push({
          sourceId: source.id,
          name: source.name,
          success: result,
          status: source.status
        });
      }
    }

    // ä¿å­˜æ›´æ–°åŽçš„çŠ¶æ€
    this.saveSources();

    logger.info('âœ… å¥åº·æ£€æŸ¥å®Œæˆ');
    return results;
  }

  /**
   * å¯åŠ¨è‡ªåŠ¨å¥åº·æ£€æŸ¥
   */
  startHealthCheck() {
    if (this.healthCheckTimer) {
      clearInterval(this.healthCheckTimer);
    }

    // ç«‹å³æ‰§è¡Œä¸€æ¬¡
    this.checkAllSourcesHealth();

    // å®šæœŸæ£€æŸ¥
    this.healthCheckTimer = setInterval(() => {
      this.checkAllSourcesHealth();
    }, this.healthCheckInterval);

    logger.info(`â° è‡ªåŠ¨å¥åº·æ£€æŸ¥å·²å¯åŠ¨ï¼ˆé—´éš”: ${this.healthCheckInterval / 1000}ç§’ï¼‰`);
  }

  /**
   * åœæ­¢è‡ªåŠ¨å¥åº·æ£€æŸ¥
   */
  stopHealthCheck() {
    if (this.healthCheckTimer) {
      clearInterval(this.healthCheckTimer);
      this.healthCheckTimer = null;
      logger.info('â¸ï¸ è‡ªåŠ¨å¥åº·æ£€æŸ¥å·²åœæ­¢');
    }
  }

  /**
   * è®°å½•ç«¯ç‚¹è¯·æ±‚ç»“æžœ
   */
  recordEndpointResult(sourceId, endpoint, success, responseTime, error = null) {
    const source = this.sources.find(s => s.id === sourceId);
    if (!source) return;

    // åˆå§‹åŒ–ç«¯ç‚¹ç»Ÿè®¡
    if (!source.endpointHealth[endpoint]) {
      source.endpointHealth[endpoint] = {
        success: 0,
        total: 0,
        avgTime: 0,
        lastError: null
      };
    }

    const stats = source.endpointHealth[endpoint];
    stats.total++;

    if (success) {
      stats.success++;
      // æ›´æ–°å¹³å‡å“åº”æ—¶é—´
      stats.avgTime = Math.floor((stats.avgTime * (stats.success - 1) + responseTime) / stats.success);
    } else {
      stats.lastError = error || 'Unknown error';
    }

    this.saveSources();
  }

  /**
   * èŽ·å–æ•°æ®æºç»Ÿè®¡ä¿¡æ¯
   */
  getSourceStats(sourceId) {
    const source = this.sources.find(s => s.id === sourceId);
    if (!source) return null;

    return {
      id: source.id,
      name: source.name,
      status: source.status,
      enabled: source.enabled,
      responseTime: source.responseTime,
      successRate: source.successRate,
      totalRequests: source.totalRequests,
      successRequests: source.successRequests,
      errors: source.errors,
      lastCheck: source.lastCheck,
      endpointHealth: source.endpointHealth
    };
  }

  /**
   * èŽ·å–æ‰€æœ‰æ•°æ®æºç»Ÿè®¡
   */
  getAllStats() {
    return this.sources.map(source => this.getSourceStats(source.id));
  }
}

export default new DataSourceManager();
