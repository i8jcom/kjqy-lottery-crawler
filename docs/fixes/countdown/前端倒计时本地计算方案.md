# 前端倒计时本地计算方案

## 问题背景

当前系统中SG彩种(新加坡彩票)的倒计时在页面刷新时会出现12秒的偏差:
- WebSocket推送的倒计时显示正常(300秒)
- 但页面刷新后,初始倒计时显示12秒
- 需要等待WebSocket推送新数据才能同步

**根本原因**: 客户端和服务器之间存在时间差异(约12秒),导致后端计算的倒计时在前端显示不准确。

## 技术方案

### 方案概述
前端不再依赖后端计算的`countdown`字段,而是使用`drawTime`字段进行本地计算:

```
前端倒计时 = (最后开奖时间 + 开奖间隔) - 当前浏览器时间
```

### API数据结构确认

所有API端点已经返回必要的字段:

#### 1. `/api/realtime-data` - 实时数据API
```json
{
  "success": true,
  "data": {
    "lotCode": "20001",
    "issue": "20260113242",
    "drawCode": "4,9,8,0,5",
    "drawTime": "2026-01-13 19:10:00",     // ✅ 最后开奖时间
    "nextIssue": "20260113243",
    "nextDrawTime": "2026-01-13 19:15:00", // ✅ 下次开奖时间
    "countdown": 242,                       // ⚠️ 不建议使用(服务器时间计算)
    "serverTime": "2026-01-13T11:10:58.123Z"
  }
}
```

#### 2. `/api/latest-data` - 最新数据API
```json
{
  "success": true,
  "data": {
    "lotCode": "20001",
    "issue": "20260113242",
    "drawCode": "4,9,8,0,5",
    "drawTime": "2026-01-13 19:10:00",     // ✅ 已添加
    "draw_time": "2026-01-13 19:10:00",    // 原始字段(也可用)
    "unixtime": 1768304100,                // ✅ Unix时间戳
    "officialCountdown": 242                // ⚠️ 不建议使用
  }
}
```

#### 3. WebSocket推送数据
```json
{
  "type": "lottery_update",
  "data": {
    "lotCode": "20001",
    "period": "20260113243",
    "opencode": "1,2,3,4,5",
    "drawTime": "2026-01-13 19:15:00",     // ✅ 开奖时间
    "unixtime": 1768304400,                // ✅ Unix时间戳
    "countdown": 300,                       // ⚠️ 不建议使用
    "officialCountdown": 300,               // ⚠️ 不建议使用
    "timestamp": 1768304400000              // WebSocket推送时间
  }
}
```

### 前端实现逻辑

#### 方案A: 使用drawTime字符串 (推荐)

```javascript
/**
 * 计算倒计时(使用drawTime字符串)
 * @param {string} drawTime - 最后开奖时间 "2026-01-13 19:10:00"
 * @param {number} drawInterval - 开奖间隔(秒) 默认300秒(5分钟)
 * @returns {number} 倒计时秒数
 */
function calculateCountdown(drawTime, drawInterval = 300) {
  // 1. 将drawTime转换为时间戳(毫秒)
  const drawTimeMs = new Date(drawTime.replace(' ', 'T') + '+08:00').getTime();

  // 2. 计算下次开奖时间
  const nextDrawTimeMs = drawTimeMs + (drawInterval * 1000);

  // 3. 获取当前浏览器时间
  const nowMs = Date.now();

  // 4. 计算倒计时(秒)
  const countdown = Math.max(0, Math.floor((nextDrawTimeMs - nowMs) / 1000));

  return countdown;
}

// 使用示例
const apiData = {
  drawTime: "2026-01-13 19:10:00",
  lotCode: "20001"
};

// SG彩种间隔300秒
const countdown = calculateCountdown(apiData.drawTime, 300);
console.log(`倒计时: ${countdown}秒`);
```

#### 方案B: 使用unixtime时间戳 (更准确)

```javascript
/**
 * 计算倒计时(使用Unix时间戳)
 * @param {number} unixtime - Unix时间戳(秒)
 * @param {number} drawInterval - 开奖间隔(秒)
 * @returns {number} 倒计时秒数
 */
function calculateCountdownFromUnixtime(unixtime, drawInterval = 300) {
  // 1. 计算下次开奖时间(秒)
  const nextDrawTime = unixtime + drawInterval;

  // 2. 获取当前时间(秒)
  const nowSeconds = Math.floor(Date.now() / 1000);

  // 3. 计算倒计时
  const countdown = Math.max(0, nextDrawTime - nowSeconds);

  return countdown;
}

// 使用示例
const apiData = {
  unixtime: 1768304100,  // 2026-01-13 19:10:00的Unix时间戳
  lotCode: "20001"
};

const countdown = calculateCountdownFromUnixtime(apiData.unixtime, 300);
console.log(`倒计时: ${countdown}秒`);
```

### Vue组件实现示例

```vue
<template>
  <div class="lottery-card">
    <h3>{{ lottery.name }}</h3>
    <div class="countdown">{{ formattedCountdown }}</div>
    <div class="issue">期号: {{ lottery.issue }}</div>
    <div class="numbers">{{ lottery.drawCode }}</div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted } from 'vue';

const props = defineProps({
  lottery: {
    type: Object,
    required: true
    // lottery包含: lotCode, drawTime, unixtime, issue, drawCode
  }
});

// 倒计时秒数
const countdown = ref(0);

// 开奖间隔配置(根据彩种类型)
const drawIntervals = {
  '200': 300,  // SG彩种: 5分钟
  '300': 300,  // AU彩种: 5分钟
  '400': 150,  // UK彩种: 2.5分钟
  '100': 75,   // SpeedyLot88极速系列: 75秒
};

// 获取当前彩种的开奖间隔
const getDrawInterval = (lotCode) => {
  const prefix = lotCode.substring(0, 3);
  return drawIntervals[prefix] || 300; // 默认5分钟
};

// 计算倒计时
const calculateCountdown = () => {
  if (!props.lottery.unixtime) return 0;

  const drawInterval = getDrawInterval(props.lottery.lotCode);
  const nextDrawTime = props.lottery.unixtime + drawInterval;
  const nowSeconds = Math.floor(Date.now() / 1000);

  return Math.max(0, nextDrawTime - nowSeconds);
};

// 格式化倒计时显示
const formattedCountdown = computed(() => {
  const minutes = Math.floor(countdown.value / 60);
  const seconds = countdown.value % 60;
  return `${minutes}:${seconds.toString().padStart(2, '0')}`;
});

// 定时器ID
let timer = null;

// 启动倒计时
const startCountdown = () => {
  // 立即计算一次
  countdown.value = calculateCountdown();

  // 每秒更新
  timer = setInterval(() => {
    countdown.value = calculateCountdown();

    // 倒计时到0时,可以触发数据刷新
    if (countdown.value === 0) {
      console.log(`${props.lottery.lotCode} 倒计时结束,等待新期号...`);
    }
  }, 1000);
};

// 停止倒计时
const stopCountdown = () => {
  if (timer) {
    clearInterval(timer);
    timer = null;
  }
};

onMounted(() => {
  startCountdown();
});

onUnmounted(() => {
  stopCountdown();
});

// 监听WebSocket推送更新
// 当收到新期号时,lottery对象会更新,需要重新计算倒计时
watch(() => props.lottery.issue, (newIssue, oldIssue) => {
  if (newIssue !== oldIssue) {
    console.log(`${props.lottery.lotCode} 检测到新期号: ${newIssue}`);
    countdown.value = calculateCountdown();
  }
});
</script>
```

## 时区处理说明

### 重要提示
所有彩种的`drawTime`都是**新加坡时间(GMT+8)**,前端计算时需要正确处理:

```javascript
// ✅ 正确: 明确指定GMT+8时区
const drawTimeMs = new Date(drawTime.replace(' ', 'T') + '+08:00').getTime();

// ❌ 错误: 使用浏览器本地时区(如果用户在其他时区会出错)
const drawTimeMs = new Date(drawTime).getTime();
```

### 不同时区用户的处理
如果用户浏览器在不同时区(如GMT+0、GMT-5等),上述代码仍然正确,因为:
1. `new Date(...+08:00)`会将新加坡时间正确转换为UTC时间戳
2. `Date.now()`返回的也是UTC时间戳
3. 两个UTC时间戳相减,得到的倒计时与时区无关

## 实施步骤

### 1. 后端确认 (已完成 ✅)
- `/api/realtime-data` 已返回 `drawTime` 和 `nextDrawTime`
- `/api/latest-data` 已返回 `drawTime` 和 `unixtime`
- WebSocket推送已包含 `drawTime` 和 `unixtime`

### 2. 前端修改 (待实施)

#### 步骤1: 更新API调用逻辑
```javascript
// src/services/api.js
export const getLotteryData = async (lotCode) => {
  const response = await axios.get(`/api/latest-data?lotCode=${lotCode}`);

  // ✅ 确保返回的数据包含必要字段
  if (!response.data.data.drawTime && !response.data.data.unixtime) {
    console.warn(`彩种 ${lotCode} 缺少drawTime/unixtime字段`);
  }

  return response.data.data;
};
```

#### 步骤2: 更新彩种卡片组件
将上述Vue组件示例代码应用到实际的彩种卡片组件中

#### 步骤3: WebSocket数据同步
```javascript
// WebSocket消息处理
socket.on('lottery_update', (message) => {
  const { lotCode, period, drawTime, unixtime } = message.data;

  // 更新彩种数据(Vue会自动触发组件重新计算)
  updateLotteryData(lotCode, {
    issue: period,
    drawTime,
    unixtime,
    // ... 其他字段
  });
});
```

## 测试验证

### 测试用例

#### 用例1: 页面刷新倒计时准确性
1. 打开页面 http://localhost:4000/realtime
2. 记录SG彩种的倒计时值(例如242秒)
3. 刷新页面
4. **预期结果**: 倒计时应该继续显示约242秒(误差±2秒),不应该跳变到12秒或其他值

#### 用例2: WebSocket更新同步
1. 页面保持打开状态
2. 等待新期号开奖(SG彩种每5分钟一期)
3. 观察WebSocket推送新期号时,倒计时是否立即重置为300秒
4. **预期结果**: 倒计时应该从300秒开始平滑递减,不应该出现跳跃

#### 用例3: 不同时区测试
1. 修改浏览器时区为GMT+0(伦敦时间)
2. 刷新页面
3. **预期结果**: 倒计时仍然准确,与时区无关

## 性能优化建议

### 1. 避免过度计算
```javascript
// ❌ 不好: 每次渲染都重新计算
const countdown = computed(() => {
  const interval = getDrawInterval(lottery.lotCode);
  const next = lottery.unixtime + interval;
  return Math.max(0, next - Math.floor(Date.now() / 1000));
});

// ✅ 更好: 使用定时器更新ref
const countdown = ref(0);
setInterval(() => {
  countdown.value = calculateCountdown();
}, 1000);
```

### 2. 批量更新优化
对于显示多个彩种的页面,使用单个定时器统一更新所有倒计时:

```javascript
// 全局倒计时管理器
class CountdownManager {
  constructor() {
    this.lotteries = new Map(); // lotCode -> lottery data
    this.timer = null;
  }

  register(lotCode, lotteryData) {
    this.lotteries.set(lotCode, lotteryData);
    if (!this.timer) this.start();
  }

  unregister(lotCode) {
    this.lotteries.delete(lotCode);
    if (this.lotteries.size === 0) this.stop();
  }

  start() {
    this.timer = setInterval(() => {
      this.lotteries.forEach((data, lotCode) => {
        // 批量更新所有彩种倒计时
        data.countdown.value = this.calculate(data);
      });
    }, 1000);
  }

  stop() {
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }
  }

  calculate(lotteryData) {
    const interval = this.getDrawInterval(lotteryData.lotCode);
    const next = lotteryData.unixtime + interval;
    return Math.max(0, next - Math.floor(Date.now() / 1000));
  }
}
```

## 兼容性说明

### 浏览器支持
- Chrome 60+
- Firefox 55+
- Safari 11+
- Edge 79+

所有现代浏览器都支持`Date.now()`和时区处理。

### 降级方案
如果某些字段缺失,提供降级处理:

```javascript
function calculateCountdown(lottery) {
  // 优先使用unixtime(最准确)
  if (lottery.unixtime) {
    return calculateFromUnixtime(lottery.unixtime);
  }

  // 其次使用drawTime
  if (lottery.drawTime) {
    return calculateFromDrawTime(lottery.drawTime);
  }

  // 最后降级使用后端倒计时(可能不准)
  if (lottery.countdown !== undefined) {
    console.warn('使用后端倒计时(可能存在偏差)');
    return lottery.countdown;
  }

  return 0;
}
```

## 总结

### 优势
1. **消除时间偏差**: 使用浏览器本地时间计算,不受客户端/服务器时间差影响
2. **实时准确**: 每秒更新,倒计时精确到秒
3. **时区独立**: 自动处理时区转换,全球用户体验一致
4. **性能优化**: 避免频繁请求后端,减少服务器压力

### 注意事项
1. 确保API始终返回`drawTime`或`unixtime`字段
2. 前端需要正确处理GMT+8时区
3. WebSocket推送新期号时要更新`unixtime`触发重新计算
4. 倒计时到0后,等待WebSocket推送新期号,不要立即请求API

### 后续维护
- 如果增加新的彩种类型,在`drawIntervals`配置中添加对应的开奖间隔
- 定期检查API返回字段,确保`drawTime`/`unixtime`始终存在
- 监控前端错误日志,及时发现时区处理问题

---
**文档版本**: v1.0
**更新时间**: 2026-01-13
**适用范围**: SG彩种(200系列)、AU彩种(300系列)、UK彩种(400系列)
